#!/bin/bash

# Fail on error, undefined vars, and fail pipelines; make globs return empty when no match
set -euo pipefail
shopt -s nullglob

# Calculate script and repository root paths so the sidebar is generated for the repo root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Directories (basenames) to exclude when walking
EXCLUDED_DIRS=(".git" "node_modules" "__pycache__" ".vscode" "docsh")
# Write sidebar to the repository root
SIDEBAR_FILE="$REPO_ROOT/_sidebar.md"

# Function to extract the title from README.md
get_title_from_readme() {
    local readme_path="$1"
    local title
    title=$(grep -m 1 "^# " "$readme_path" | sed 's/^# //')
    echo "$title"
}

# Start writing to _sidebar.md (clear)
> "$SIDEBAR_FILE"

# Write a small header with timestamp and options used
write_header() {
    local include_root_flag="$1"
    printf "<!-- Generated by docsh/10_generate_sidebar.sh on %s -->\n" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$SIDEBAR_FILE"
    printf "<!-- include_root=%s -->\n\n" "$include_root_flag" >> "$SIDEBAR_FILE"
}

# Function to walk through directories and generate the sidebar
generate_sidebar() {
    local dir_path="$1"
    local indent="$2"

    # If a .docshignore file exists in this directory, skip it and its subtree
    if [[ -f "$dir_path/.docshignore" ]]; then
        echo "Skipping directory due to .docshignore: $dir_path"
        return
    fi

    # Check for README.md in the current directory
    if [[ -f "$dir_path/README.md" ]]; then
        local title
        title=$(get_title_from_readme "$dir_path/README.md")
        if [[ -z "$title" ]]; then
            title=$(basename "$dir_path")
        fi

        # Compute path relative to repo root and ensure it starts with a single '/'
        local rel_path
        rel_path="${dir_path#$REPO_ROOT}"
        # Remove any leading slash that remains after prefix removal
        rel_path="${rel_path#/}"
        # Trim trailing slash
        rel_path="${rel_path%/}"
        if [[ -z "$rel_path" ]]; then
            rel_path="/"
        else
            rel_path="/$rel_path/"
        fi

    # Collapse any accidental multiple slashes into a single slash (use sed)
    rel_path="$(printf '%s' "$rel_path" | sed -E 's:/{2,}:/:g')"

        echo "$indent* [$title]($rel_path)" >> "$SIDEBAR_FILE"
        echo "Added: $rel_path with title '$title'"
    else
        echo "Skipped directory (no README.md): $dir_path"
    fi

    # Recurse into subdirectories
    for subdir in "$dir_path"/*/; do
        # Ensure subdir is a directory
        if [[ -d "$subdir" ]]; then
            local base_dir
            base_dir=$(basename "$subdir")
            # Check if this directory should be excluded
            if [[ ! " ${EXCLUDED_DIRS[*]} " =~ " ${base_dir} " ]]; then
                # Also skip if the subdir contains .docshignore
                if [[ -f "$subdir/.docshignore" ]]; then
                    echo "Skipping subdirectory due to .docshignore: $subdir"
                else
                    generate_sidebar "$subdir" "  $indent"
                fi
            else
                echo "Excluding directory from recursion: $subdir"
            fi
        fi
    done
}

# Parse CLI options
INCLUDE_ROOT=false
while [[ ${1:-} != "" ]]; do
    case "$1" in
        -r|--include-root)
            INCLUDE_ROOT=true
            shift
            ;;
        -h|--help)
            cat <<EOF
Usage: $(basename "$0") [options]

Options:
  -r, --include-root   Include the repository root README as the top-level entry
  -h, --help           Show this help and exit
EOF
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 2
            ;;
    esac
done


# Write header indicating chosen options
write_header "$INCLUDE_ROOT"

# If requested, include the repo root README as the first (and only) entry.
# When include_root is true, the root's recursion already visits top-level directories,
# so skip the separate top-level directory loop to avoid duplicate entries.
if [[ "$INCLUDE_ROOT" == true ]]; then
    generate_sidebar "$REPO_ROOT" ""
else
    # Generate sidebar starting from each top-level directory under the repository root.
    for top in "$REPO_ROOT"/*/; do
        if [[ -d "$top" ]]; then
            base_dir=$(basename "$top")
            if [[ ! " ${EXCLUDED_DIRS[*]} " =~ " ${base_dir} " ]]; then
                # Skip top-level dirs that contain .docshignore
                if [[ -f "$top/.docshignore" ]]; then
                    echo "Skipping top-level directory due to .docshignore: $top"
                else
                    generate_sidebar "$top" ""
                fi
            else
                echo "Excluding top-level directory from scan: $top"
            fi
        fi
    done
fi

echo "Sidebar generation complete: $SIDEBAR_FILE"